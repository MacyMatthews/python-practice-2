# -*- coding: utf-8 -*-
"""coding2

Automatically generated by Colaboratory.
"""
import itertools
import re
'''
Returns the proposition, formatted in string form.
Parameters:
prop (list): proposition in nested list form
Returns:
string: 'prop' in string form
'''
def format_prop(prop):
  if 0 == len(prop):
    return ""
  elif 1 == len(prop):
    return str(prop[0])
  else:
    if prop[0] == 'not':
      p1 = format_prop(prop[1])
      return "(not" + " " + p1 + ")"
    else:
      p2 = format_prop(prop[1])
      p3 = format_prop(prop[2])
    if prop[0] == "or":
      return "(" + p2 + " or " + p3 + ")"
    elif prop[0] == "and":
      return "(" + p2 + " and " + p3 + ")"
    elif prop[0] == "if":
      return "(" + p2 + " -> " + p3 + ")"
    elif prop[0]=="iff":
      return "(" + p2 + " <-> " + p3 + ")"
    else:
      return "(" + p2 + " xor " + p3 + ")"
   
'''
Returns the evaluation (True or False) as an int (1 or 0) of the proposition,
given a proposition in list form and a list of values for each atomic variable.
Parameters:
prop (list): proposition in nested list form.
values (list): list of integers, either 0 or 1 indicating False or True for
each atomic variable in the proposition. 
Returns:
int: 0 for False, 1 for True
'''
def eval_prop(prop, values):
    # BASE CASE: #####################################
    if len(prop) < 2:
        # fill in here # 
        atomic_prop_id =  int(re.sub("[^0-9]", "", prop[0]))
        return values[atomic_prop_id - 1]
    ##################################################
    # UNARY OPERATOR (not): ##########################
    elif 2 == len(prop):
        # the following two variable declarations are missing LHS #
        op = prop[0] # missing LHS
        prop1 = prop[1] # missing LHS
        if "not" == op:
          eval = eval_prop(prop1, values)
          if eval < 1: #false
            return 1
          else:
            return 0 
        else:
            raise ValueError("Unary proposition is not not.")
    ##################################################
    # BINARY OPERATOR (and, or, if, iff, xor): #######
    elif 3 == len(prop):
        # the following three variable declarations are missing LHS #
        op = prop[0] # missing LHS
        prop1 = prop[1] # missing LHS
        prop2 = prop[2] # missing LHS
        if op not in ("if", "iff", "or", "and", "xor"):
            raise ValueError("Binary proposition does not have valid connectives.")
        # evaluate left and right sides of a binary operation
        left = eval_prop(prop1, values)
        right = eval_prop(prop2, values)
        # the line here is an example. fill in the rest.
        if "and" == op:
            return int(left and right)

        elif "iff" == op:
          if left == right:
            return 1
          else:
            return 0

        elif "if" == op:
          if left == right:
            return 1
          elif right == 1:
            return 1
          else:
            return 0

        elif "or" == op:
          if left == 0 and right == 0:
            return 0
          else:
            return 1
        else:
          if left == right:
            return 1
          else:
            return 0
        
    # INVALID LENGTH ####################################
    else:
        raise ValueError("Proposition incorrect length.")
    #####################################################
if __name__ == '__main__':
    print("---------------------------------------")
    print("Coding Assignment 2: Propositional Logic")
    print("---------------------------------------")
    print()
    values = [1]
    prop = ["not", ["p1"]]
    ps_str = " ".join("p{}={}".format(i + 1, v) for i, v in enumerate(values))
    print("Evaluating proposition p =", format_prop(prop))
    prop_val = eval_prop(prop, values)
    print("over", ps_str, ":", prop_val)
    print()
    values = [1, 1]
    prop = ["and", ["p1"], ["p2"]]
    ps_str = " ".join("p{}={}".format(i + 1, v) for i, v in enumerate(values))
    print("Evaluating proposition p =", format_prop(prop))
    prop_val = eval_prop(prop, values)
    print("over", ps_str, ":", prop_val)
    print()
    values = [1, 0]
    prop = ["iff", ["p1"],["p2"]]
    ps_str = " ".join("p{}={}".format(i + 1, v) for i, v in enumerate(values))
    print("Evaluating proposition p =", format_prop(prop))
    prop_val = eval_prop(prop, values)
    print("over", ps_str, ":", prop_val)
    print()
    values = [1, 1, 0]
    prop = ["if", ["and", ["p1"], ["not", ["p2"]]], ["p3"]]
    ps_str = " ".join("p{}={}".format(i + 1, v) for i, v in enumerate(values))
    prop_str = format_prop(prop)
    print("Evaluating proposition p =", prop_str)
    prop_val = eval_prop(prop, values)
    print("over", ps_str, ":", prop_val)
    print()
    values = [1, 0, 1]
    prop = ["iff", ["p1"], ["or", ["p2"], ["not", ["p3"]]]]
    ps_str = " ".join("p{}={}".format(i + 1, v) for i, v in enumerate(values))
    print("Evaluating proposition p =", format_prop(prop))
    prop_val = eval_prop(prop, values)
    print("over", ps_str, ":", prop_val)

